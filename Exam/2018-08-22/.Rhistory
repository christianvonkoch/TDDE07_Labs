library(mvtnorm)
# titanic = titanic[sample(1316,184),]
y <- as.vector(titanic[,1])
X <- as.matrix(titanic[,-1])
covNames <- names(titanic)[2:length(names(titanic))]
nPara <- dim(X)[2]
# Setting up the prior
tau <- 50
mu <- as.vector(rep(0,nPara)) # Prior mean vector
Sigma <- tau^2*diag(nPara)
# Defining the functions that returns the log posterior
logPost<- function(betaVect,y,X,mu,Sigma){
nPara <- length(betaVect);
linPred <- X%*%betaVect;
# evaluating the log-likelihood
logLik <- sum( linPred*y -log(1 + exp(linPred)));
if (abs(logLik) == Inf) logLik = -20000; # Likelihood is not finite, stear the optimizer away from here!
# evaluating the prior
logPrior <- dmvnorm(betaVect, matrix(0,nPara,1), Sigma, log=TRUE);
# add the log prior and log-likelihood together to get log posterior
return(logLik + logPrior)
}
initVal = rep(10,nPara)
OptimResults<-optim(initVal,logPost,gr=NULL,y,X,mu,Sigma,method=c("BFGS"),control=list(fnscale=-1),hessian=TRUE)
# Printing the results to the screen
postMode <- OptimResults$par
postCov <- -solve(OptimResults$hessian) # Posterior covariance matrix is -inv(Hessian)
names(postMode) <- covNames # Naming the coefficient by covariates
approxPostStd <- sqrt(diag(postCov)) # Computing approximate standard deviations.
names(approxPostStd) <- covNames # Naming the coefficient by covariates
par(mfrow=c(2,2))
for(i in 2:5){
grid = seq(postMode[i] - 3*approxPostStd[i],postMode[i] + 3*approxPostStd[i],length=1000)
plot(grid,dnorm(grid,postMode[i],approxPostStd[i]),type="l",main=c(names(postMode)[i],"posterior"),ylab="density")
}
# 2b
Pbeta1 = dnorm(0,postMode[2],approxPostStd[2])
Pbeta1
# The probability is 0.000128 which is the probability that an adult
# is less likely to survive than a child.
# 2c
woman = c(1,1,0,1,0)
man = c(1,1,1,0,0)
Ns = 1000
betaSim = matrix(0,Ns,nPara)
for(i in 1:Ns) {
betaSim[i,] <- rmvnorm(1,postMode,postCov)
}
linPredWoman <- woman%*%t(betaSim)
linPredMan <- man%*%t(betaSim)
womanSim <- rbinom(Ns,1,exp(linPredWoman) / (1+exp(linPredWoman)))
manSim <- rbinom(Ns,1,exp(linPredMan) / (1+exp(linPredMan)))
ySim <- as.numeric(womanSim & !manSim)
mean(ySim)
# Roughly 0.79
# 2a
library(mvtnorm)
# titanic = titanic[sample(1316,184),]
y <- as.vector(titanic[,1])
X <- as.matrix(titanic[,-1])
covNames <- names(titanic)[2:length(names(titanic))]
nPara <- dim(X)[2]
# Setting up the prior
tau <- 50
mu <- as.vector(rep(0,nPara)) # Prior mean vector
Sigma <- tau^2*diag(nPara)
# Defining the functions that returns the log posterior
logPost<- function(betaVect,y,X,mu,Sigma){
nPara <- length(betaVect);
linPred <- X%*%betaVect;
# evaluating the log-likelihood
logLik <- sum( linPred*y -log(1 + exp(linPred)));
if (abs(logLik) == Inf) logLik = -20000; # Likelihood is not finite, stear the optimizer away from here!
# evaluating the prior
logPrior <- dmvnorm(betaVect, matrix(0,nPara,1), Sigma, log=TRUE);
# add the log prior and log-likelihood together to get log posterior
return(logLik + logPrior)
}
initVal = rep(10,nPara)
OptimResults<-optim(initVal,logPost,gr=NULL,y,X,mu,Sigma,method=c("BFGS"),control=list(fnscale=-1),hessian=TRUE)
# Printing the results to the screen
postMode <- OptimResults$par
postCov <- -solve(OptimResults$hessian) # Posterior covariance matrix is -inv(Hessian)
names(postMode) <- covNames # Naming the coefficient by covariates
approxPostStd <- sqrt(diag(postCov)) # Computing approximate standard deviations.
names(approxPostStd) <- covNames # Naming the coefficient by covariates
par(mfrow=c(2,2))
for(i in 2:5){
grid = seq(postMode[i] - 3*approxPostStd[i],postMode[i] + 3*approxPostStd[i],length=1000)
plot(grid,dnorm(grid,postMode[i],approxPostStd[i]),type="l",main=c(names(postMode)[i],"posterior"),ylab="density")
}
# 2b
Pbeta1 = dnorm(0,postMode[2],approxPostStd[2])
Pbeta1
# The probability is 0.000128 which is the probability that an adult
# is less likely to survive than a child.
# 2c
woman = c(1,1,0,1,0)
man = c(1,1,1,0,0)
Ns = 1000
betaSim = matrix(0,Ns,nPara)
for(i in 1:Ns) {
betaSim[i,] <- rmvnorm(1,postMode,postCov)
}
linPredWoman <- woman%*%t(betaSim)
linPredMan <- man%*%t(betaSim)
womanSim <- rbinom(Ns,1,exp(linPredWoman) / (1+exp(linPredWoman)))
manSim <- rbinom(Ns,1,exp(linPredMan) / (1+exp(linPredMan)))
ySim <- as.numeric(womanSim & !manSim)
mean(ySim)
# Roughly 0.79
# 2a
library(mvtnorm)
# titanic = titanic[sample(1316,184),]
y <- as.vector(titanic[,1])
X <- as.matrix(titanic[,-1])
covNames <- names(titanic)[2:length(names(titanic))]
nPara <- dim(X)[2]
# Setting up the prior
tau <- 50
mu <- as.vector(rep(0,nPara)) # Prior mean vector
Sigma <- tau^2*diag(nPara)
# Defining the functions that returns the log posterior
logPost<- function(betaVect,y,X,mu,Sigma){
nPara <- length(betaVect);
linPred <- X%*%betaVect;
# evaluating the log-likelihood
logLik <- sum( linPred*y -log(1 + exp(linPred)));
if (abs(logLik) == Inf) logLik = -20000; # Likelihood is not finite, stear the optimizer away from here!
# evaluating the prior
logPrior <- dmvnorm(betaVect, matrix(0,nPara,1), Sigma, log=TRUE);
# add the log prior and log-likelihood together to get log posterior
return(logLik + logPrior)
}
initVal = rep(10,nPara)
OptimResults<-optim(initVal,logPost,gr=NULL,y,X,mu,Sigma,method=c("BFGS"),control=list(fnscale=-1),hessian=TRUE)
# Printing the results to the screen
postMode <- OptimResults$par
postCov <- -solve(OptimResults$hessian) # Posterior covariance matrix is -inv(Hessian)
names(postMode) <- covNames # Naming the coefficient by covariates
approxPostStd <- sqrt(diag(postCov)) # Computing approximate standard deviations.
names(approxPostStd) <- covNames # Naming the coefficient by covariates
par(mfrow=c(2,2))
for(i in 2:5){
grid = seq(postMode[i] - 3*approxPostStd[i],postMode[i] + 3*approxPostStd[i],length=1000)
plot(grid,dnorm(grid,postMode[i],approxPostStd[i]),type="l",main=c(names(postMode)[i],"posterior"),ylab="density")
}
# 2b
Pbeta1 = dnorm(0,postMode[2],approxPostStd[2])
Pbeta1
# The probability is 0.000128 which is the probability that an adult
# is less likely to survive than a child.
# 2c
woman = c(1,1,0,1,0)
man = c(1,1,1,0,0)
Ns = 1000
betaSim = matrix(0,Ns,nPara)
for(i in 1:Ns) {
betaSim[i,] <- rmvnorm(1,postMode,postCov)
}
linPredWoman <- woman%*%t(betaSim)
linPredMan <- man%*%t(betaSim)
womanSim <- rbinom(Ns,1,exp(linPredWoman) / (1+exp(linPredWoman)))
manSim <- rbinom(Ns,1,exp(linPredMan) / (1+exp(linPredMan)))
ySim <- as.numeric(womanSim & !manSim)
mean(ySim)
# Roughly 0.79
source('~/SKOLA/LIU/Åk 4/TDDE07/TDDE07_Labs/Exam/2018-08-22/Code/Exam732A91_180822_Sol.R', echo=TRUE)
source('~/SKOLA/LIU/Åk 4/TDDE07/TDDE07_Labs/Exam/2018-08-22/Code/Exam732A91_180822_Sol.R', echo=TRUE)
# Print the posterior mean and standard deviation
print(fit,digits=3,pars = c("mu", "sigma2"),probs=c(.025,.975))
# Joint posterior
pairs(fit,pars = c("mu", "sigma2"))
# Joint posterior
pairs(fit,pars = c("mu", "sigma2"))
par(mfrow=c(2,2))
for(i in 2:5){
grid = seq(postMode[i] - 3*approxPostStd[i],postMode[i] + 3*approxPostStd[i],length=1000)
plot(grid,dnorm(grid,postMode[i],approxPostStd[i]),type="l",main=c(names(postMode)[i],"posterior"),ylab="density")
}
for (i in 2:nFeatures) {
plot(betaGrid, dnorm(betaGrid, mean=mu_n[i], sd=approx_PostStd[i]),
main=paste("Marginal posterior of", covNames[i]), xlab=covNames[i], ylab="Density", type="l", lwd=2)
}
source('~/SKOLA/LIU/Åk 4/TDDE07/TDDE07_Labs/Exam/2018-08-22/2018-08-22_Assignment2.R', echo=TRUE)
source('~/SKOLA/LIU/Åk 4/TDDE07/TDDE07_Labs/Exam/2018-08-22/2018-08-22_Assignment2.R', echo=TRUE)
source('~/SKOLA/LIU/Åk 4/TDDE07/TDDE07_Labs/Exam/2018-08-22/2018-08-22_Assignment2.R', echo=TRUE)
source('~/SKOLA/LIU/Åk 4/TDDE07/TDDE07_Labs/Exam/2018-08-22/2018-08-22_Assignment2.R', echo=TRUE)
source('~/SKOLA/LIU/Åk 4/TDDE07/TDDE07_Labs/Exam/2018-08-22/2018-08-22_Assignment2.R', echo=TRUE)
mu_n
post_mode
omega_0=diag(nFeatures)
betaHat=solve(t(X)%*%X)%*%t(X)%*%y
mu_n=solve((t(X)%*%X+omega_0))%*%(t(X)%*%X%*%betaHat+omega_0%*%mu_prior)
omega_n=t(X)%*%X+omega_0
omega_n_approx=sqrt(diag(omega_n))
par(mfrow=c(2,2))
omega_0=diag(nFeatures)
betaHat=solve(t(X)%*%X)%*%t(X)%*%y
mu_n=solve((t(X)%*%X+omega_0))%*%(t(X)%*%X%*%betaHat+omega_0%*%mu_prior)
omega_n=t(X)%*%X+omega_0
omega_n_approx=sqrt(diag(omega_n))
par(mfrow=c(2,2))
betaGrid=seq(-2,2,0.01)
for (i in 2:nFeatures) {
plot(betaGrid, dnorm(betaGrid, mean=mu_n[i], sd=tau*omega_n_approx[i]),
main=paste("Marginal posterior of", covNames[i]), xlab=covNames[i], ylab="Density", type="l", lwd=2)
}
prob=pnorm(0, mean=mu_n[which(covNames=="adult")], sd=approx_PostStd[which(covNames=="adult")])
View(omega_n)
betaGrid=seq(-2,2,0.01)
par(mfrow=c(2,2))
for (i in 2:nFeatures) {
plot(betaGrid, dnorm(betaGrid, mean=postMode[i], sd=approx_PostStd[i]),
main=paste("Marginal posterior of", covNames[i]), xlab=covNames[i], ylab="Density", type="l", lwd=2)
}
par(mfrow=c(2,2))
for (i in 2:nFeatures) {
grid=seq(postMode[i]-3*approx_PostStd[i])
plot(grid, dnorm(grid, mean=postMode[i], sd=approx_PostStd[i]),
main=paste("Marginal posterior of", covNames[i]), xlab=covNames[i], ylab="Density", type="l", lwd=2)
}
par(mfrow=c(2,2))
for (i in 2:nFeatures) {
grid=seq(postMode[i]-3*approx_PostStd[i], postMode[i]+3*approx_PostStd[i])
plot(grid, dnorm(grid, mean=postMode[i], sd=approx_PostStd[i]),
main=paste("Marginal posterior of", covNames[i]), xlab=covNames[i], ylab="Density", type="l", lwd=2)
}
par(mfrow=c(2,2))
for (i in 2:nFeatures) {
grid=seq(postMode[i]-3*approx_PostStd[i], postMode[i]+3*approx_PostStd[i], length=1000)
plot(grid, dnorm(grid, mean=postMode[i], sd=approx_PostStd[i]),
main=paste("Marginal posterior of", covNames[i]), xlab=covNames[i], ylab="Density", type="l", lwd=2)
}
par(mfrow=c(2,2))
for(i in 2:5){
grid = seq(postMode[i] - 3*approxPostStd[i],postMode[i] + 3*approxPostStd[i],length=1000)
plot(grid,dnorm(grid,postMode[i],approxPostStd[i]),type="l",main=c(names(postMode)[i],"posterior"),ylab="density")
}
help(titanic)
?titanic
man=c(1,1,1,0,0)
woman=c(1,1,0,1,0)
man=c(1,1,1,0,0)
woman=c(1,1,0,1,0)
nDraws=5000
results=matrix(0,nDraws, nFeatures)
man=c(1,1,1,0,0)
woman=c(1,1,0,1,0)
nDraws=5000
results=matrix(0,nDraws, nFeatures)
for (i in 1:nDraws) {
results[i,]=rmvnorm(1, mean=postMode, sigma=postCov)
}
manPred=results%*%man
womanPred=results%*%woman
manPred=results%*%man
womanPred=results%*%woman
manSim=rbinom(nDraws, 1, exp(manPred)/(1+exp(manPred)))
womanSim=rbinom(nDraws, 1, exp(womanPred)/(1+exp(womanPred)))
final=as.numeric(womanSim & !manSim)
1 & !0
1 & 1
1 & !0
1 & !0
1 & !1
0 & 0
final=ifelse(womanSim == 1 & manSim ==0, 1, 0)
mean(final)
# 2b
Pbeta1 = dnorm(0,postMode[2],approxPostStd[2])
Pbeta1
# 2b
Pbeta1 = pnorm(0,postMode[2],approxPostStd[2])
Pbeta1
# 2b
Pbeta1 = dnorm(0,postMode[2],approxPostStd[2])
Pbeta1
source('~/SKOLA/LIU/Åk 4/TDDE07/TDDE07_Labs/Exam/2018-08-22/2018-08-22_Assignment2.R', echo=TRUE)
prob=pnorm(0, mean=mu_n[which(covNames=="adult")], sd=approx_PostStd[which(covNames=="adult")])
prob
prob=pnorm(0, mean=postMode[which(covNames=="adult")], sd=approx_PostStd[which(covNames=="adult")])
prob
data=c(2, 1, 12)
alpha=1/2
beta=1/2
data=c(2, 1, 12)
n=length(data)
margLikelihood1=gamma(alpha+beta)*gamma(alpha+n)/(gamma(alpha)*gamma(beta)*gamma(beta+sum(data)))
margLikelihood2=0.5^n*(1-0.5)^sum(data)
prior1=1/10
prior2=9/10
posterior1=margLikelihood1*prior1
posterior2=margLikelihood2*prior2
posterior1_norm=posterior1/sum(c(posterior1, posterior2))
posterior2_norm=posterior2/sum(c(posterior1, posterior2))
alpha=1/2
beta=1/2
alpha=1/2
2
alpha=1/2
beta=1/2
data=c(2, 1, 12)
n=length(data)
margLikelihood1=gamma(alpha+beta)*gamma(alpha+n)/(gamma(alpha)*gamma(beta)*gamma(beta+sum(data)))
margLikelihood2=0.5^n*(1-0.5)^sum(data)
prior1=1/10
prior2=9/10
posterior1=margLikelihood1*prior1
posterior2=margLikelihood2*prior2
posterior1_norm=posterior1/sum(c(posterior1, posterior2))
posterior2_norm=posterior2/sum(c(posterior1, posterior2))
3
# 3c
n = 3
xbar = 5
a = .5
b = .5
logmarglik1 <- lbeta(n+a,n*xbar+b) - lbeta(a,b)
logmarglik2 <- n*log(.5) + n*xbar*log(.5)
unnorm_modelprob = c(exp(logmarglik1)/10,exp(logmarglik2)*9/10)
modelprob = unnorm_modelprob / sum(unnorm_modelprob)
modelprob
margLikelihood1=gamma(alpha+beta)*gamma(alpha+n)*gamma(beta+sum(data))/(gamma(alpha)*gamma(beta)*
gamma(beta+sum(data)+alpha+n))
margLikelihood2=0.5^n*(1-0.5)^sum(data)
prior1=1/10
prior2=9/10
posterior1=margLikelihood1*prior1
posterior2=margLikelihood2*prior2
posterior1_norm=posterior1/sum(c(posterior1, posterior2))
posterior2_norm=posterior2/sum(c(posterior1, posterior2))
help(dirichlet)
?dirichlet
help(dirich)
help("distributions")
alpha1=1
alpha2=1
alpha3=1
alpha=c(alpha1, alpha2, alpha3)
simDirich = function(alpha) {
nComp=length(alpha)
gammavec=rep(0,nComp)
for (i in 1:nComp) {
x=rgamma(1, alpha[i], 1)
gammavec[i]=x
}
z=gammavec/sum(gammavec)
return(z)
}
# Assuming uniform Dirichlet prior, i.e. Dirichlet(1,1,1)
nComp=3
alpha=rep(1,nComp)
simDirich = function(alpha) {
nComp=length(alpha)
gammavec=rep(0,nComp)
for (i in 1:nComp) {
x=rgamma(1, alpha[i], 1)
gammavec[i]=x
}
z=gammavec/sum(gammavec)
return(z)
}
nIter=5000
help(multinom)
# Assuming uniform Dirichlet prior, i.e. Dirichlet(1,1,1)
nComp=3
alpha=rep(1,nComp)
simDirich = function(alpha) {
nComp=length(alpha)
gammavec=rep(0,nComp)
for (i in 1:nComp) {
x=rgamma(1, alpha[i], 1)
gammavec[i]=x
}
z=gammavec/sum(gammavec)
return(z)
}
nIter=5000
dirichlet=matrix(0, nIter, nComp)
resultMatrix=matrix(0,nIter,nComp)
for (i in 1:nIter) {
dirichlet[i,]=simDirich(alpha)
resultMatrix=rmultinom(1,nComp,dirichlet[i,])
}
prob1=resultMatrix[resultMatrix[,1]/sum(resultMatrix[,1:nComp])>0.5,]
View(resultMatrix)
nIter=5000
dirichlet=matrix(0, nIter, nComp)
resultMatrix=matrix(0,nIter,nComp)
for (i in 1:nIter) {
dirichlet[i,]=simDirich(alpha)
resultMatrix[i,]=rmultinom(1,nComp,dirichlet[i,])
}
prob1=resultMatrix[resultMatrix[,1]/sum(resultMatrix[,1:nComp])>0.5,]
View(prob1)
View(resultMatrix)
help(rbinom)
# Assuming uniform Dirichlet prior, i.e. Dirichlet(1,1,1)
nComp=3
alpha=rep(1,nComp)
simDirich = function(alpha) {
nComp=length(alpha)
gammavec=rep(0,nComp)
for (i in 1:nComp) {
x=rgamma(1, alpha[i], 1)
gammavec[i]=x
}
z=gammavec/sum(gammavec)
return(z)
}
nIter=5000
dirichlet=matrix(0, nIter, nComp)
resultMatrix=matrix(0,nIter,nComp)
for (i in 1:nIter) {
dirichlet[i,]=simDirich(alpha)
resultMatrix[i,]=rmultinom(1,400,dirichlet[i,])
}
View(results)
View(resultMatrix)
prob1=resultMatrix[resultMatrix[,1]/sum(resultMatrix[,1:nComp])>0.5,]
prob1=resultMatrix[which(resultMatrix[,1]/(resultMatrix[,1]+resultMatrix[,2]+resultMatrix[,3])>0.5),]
View(prob1)
prob1_vals=resultMatrix[which(resultMatrix[,1]/(resultMatrix[,1]+resultMatrix[,2]+resultMatrix[,3])>0.5),]
prob1=dim(prob1_vals)[1]/nIter
prob1
resultMatrix2=matrix(0,nIter, nComp)
prob2_vals=resultMatrix[which(resultMatrix[,1]>resultMatrix[,2] & resultMatrix[,1]>resultMatrix[,3]),]
View(prob2_vals)
prob2=dim(prob2_vals)[1]/nIter
prob2
# Assuming uniform Dirichlet prior, i.e. Dirichlet(1,1,1)
nComp=3
alpha=rep(1,nComp)
data=c(184, 67, 149)
help(dmultinom)
nIter=5000
dirichlet=matrix(0, nIter, nComp)
# Assuming uniform Dirichlet prior, i.e. Dirichlet(1,1,1)
nComp=3
alpha=rep(1,nComp)
data=c(184, 67, 149)
simDirich = function(alpha) {
nComp=length(alpha)
gammavec=rep(0,nComp)
for (i in 1:nComp) {
x=rgamma(1, alpha[i], 1)
gammavec[i]=x
}
z=gammavec/sum(gammavec)
return(z)
}
nIter=5000
dirichlet=matrix(0, nIter, nComp)
resultMatrix=matrix(0,nIter,nComp)
for (i in 1:nIter) {
dirichlet[i,]=simDirich(alpha)
resultMatrix[i,]=dmultinom(data,400,dirichlet[i,])
}
prob1_vals=resultMatrix[which(resultMatrix[,1]/(resultMatrix[,1]+resultMatrix[,2]+resultMatrix[,3])>0.5),]
prob1=dim(prob1_vals)[1]/nIter
prob1
View(resultMatrix)
# Assuming uniform Dirichlet prior, i.e. Dirichlet(1,1,1)
nComp=3
alphaPrior=rep(1,nComp)
data=c(184, 67, 149)
alphaPost=alphaPrior+data
simDirich = function(alpha) {
nComp=length(alpha)
gammavec=rep(0,nComp)
for (i in 1:nComp) {
x=rgamma(1, alpha[i], 1)
gammavec[i]=x
}
z=gammavec/sum(gammavec)
return(z)
}
nIter=5000
dirichlet=matrix(0, nIter, nComp)
nIter=5000
dirichlet=matrix(0, nIter, nComp)
for (i in 1:nIter) {
dirichlet[i,]=simDirich(alphaPost)
}
(dirichlet[,1]>0.5)
prob=mean(dirichlet[,1]>0.5)
prob
# Assuming uniform Dirichlet prior, i.e. Dirichlet(1,1,1)
nComp=3
alphaPrior=rep(1,nComp)
data=c(184, 67, 149)
alphaPost=alphaPrior+data
simDirich = function(alpha) {
nComp=length(alpha)
gammavec=rep(0,nComp)
for (i in 1:nComp) {
x=rgamma(1, alpha[i], 1)
gammavec[i]=x
}
z=gammavec/sum(gammavec)
return(z)
}
nIter=10000
dirichlet=matrix(0, nIter, nComp)
for (i in 1:nIter) {
dirichlet[i,]=simDirich(alphaPost)
}
prob=mean(dirichlet[,1]>0.5)
prob
mean(dirichlet[,1]>dirichlet[,2] & dirichlet[,1]>dirichlet[,3])
View(dirichlet)
