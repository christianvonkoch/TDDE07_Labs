#install.packages("rstan")
mu=10
sigma_sq=2
T=200
x_init=mu
phi_vector=seq(-0.9,0.9,0.1)
results_matrix=matrix(0,200,length(phi_vector))
results_matrix[1,]=x_init
counter=1
set.seed(12345)
AR_process_function=function(mu, sigma_sq, T, phi) {
x_init=mu
result=rep(0,T)
result[1]=x_init
for (i in 2:T) {
epsilon=rnorm(1,0,sqrt(sigma_sq))
result[i]=mu+phi*(result[i-1]-mu)+epsilon
}
return(result)
}
results_matrix=matrix(0,T,length(phi_vector))
counter=1
for (phi in phi_vector) {
results_matrix[,counter]=AR_process_function(mu,sigma_sq,T,phi)
counter=counter+1
}
iter=seq(1,200,1)
counter=1
for (i in 1:length(phi_vector)) {
if (counter %% 6 == 0) {
plot(iter, results_matrix[,i], main="Plot of realization of AR-process", sub=paste("Phi =", phi_vector[i]),
xlab="Iteration", ylab="Value", type="l", col="grey")
}
counter=counter+1
}
library(rstan)
postDraws_x <- extract(fit_x)
postDraws_y <- extract(fit_y)
print(fit_x)
print(fit_y)
mean_vector_x=fit_x@.MISC$summary$msd[,1]
cred_vector_x=fit_x@.MISC$summary$quan
eff_vector_x=fit_x@.MISC$summary$ess
mean_vector_y=fit_y@.MISC$summary$msd[,1]
cred_vector_y=fit_y@.MISC$summary$quan
eff_vector_y=fit_y@.MISC$summary$ess
# Do traceplots of the first chain
plot(postDraws_x$mu[1000:2000], postDraws_x$phi[1000:2000],ylab="phi", xlab="mu", main="Traceplot")
# Do traceplots of the first chain
plot(postDraws_y$mu[1000:2000],postDraws_y$phi[1000:2000],ylab="mu", xlab="mu",main="Traceplot")
help(stan)
```{r results = "hide"}
knitr::opts_chunk$set(echo = TRUE)
#install.packages("rstan")
mu=10
sigma_sq=2
T=200
x_init=mu
phi_vector=seq(-0.9,0.9,0.1)
results_matrix=matrix(0,200,length(phi_vector))
results_matrix[1,]=x_init
counter=1
set.seed(12345)
AR_process_function=function(mu, sigma_sq, T, phi) {
x_init=mu
result=rep(0,T)
result[1]=x_init
for (i in 2:T) {
epsilon=rnorm(1,0,sqrt(sigma_sq))
result[i]=mu+phi*(result[i-1]-mu)+epsilon
}
return(result)
}
results_matrix=matrix(0,T,length(phi_vector))
counter=1
for (phi in phi_vector) {
results_matrix[,counter]=AR_process_function(mu,sigma_sq,T,phi)
counter=counter+1
}
iter=seq(1,200,1)
counter=1
for (i in 1:length(phi_vector)) {
if (counter %% 6 == 0) {
plot(iter, results_matrix[,i], main="Plot of realization of AR-process", sub=paste("Phi =", phi_vector[i]),
xlab="Iteration", ylab="Value", type="l", col="grey")
}
counter=counter+1
}
library(rstan)
x=rep(0,T)
y=rep(0,T)
set.seed(12345)
x=AR_process_function(mu, sigma_sq, T, 0.3)
set.seed(12345)
y=AR_process_function(mu, sigma_sq, T, 0.95)
StanModel= '
data {
int<lower=0> N;
vector[N] y;
}
parameters {
real mu;
real phi;
real<lower=0> sigma;
}
model {
for (n in 2:N)
y[n] ~ normal(mu + phi * (y[n-1]-mu), sigma);
}
'
data_x=list(N=T, y=x)
data_y=list(N=T, y=y)
fit_x=stan(model_code=StanModel, data=data_x)
fit_y=stan(model_code=StanModel, data=data_y)
library(rstan)
postDraws_x <- extract(fit_x)
postDraws_y <- extract(fit_y)
print(fit_x)
print(fit_y)
mean_vector_x=fit_x@.MISC$summary$msd[,1]
cred_vector_x=fit_x@.MISC$summary$quan
eff_vector_x=fit_x@.MISC$summary$ess
mean_vector_y=fit_y@.MISC$summary$msd[,1]
cred_vector_y=fit_y@.MISC$summary$quan
eff_vector_y=fit_y@.MISC$summary$ess
# Do traceplots of the first chain
plot(postDraws_x$mu[1000:2000], postDraws_x$phi[1000:2000],ylab="phi", xlab="mu", main="Traceplot")
# Do traceplots of the first chain
plot(postDraws_y$mu[1000:2000],postDraws_y$phi[1000:2000],ylab="mu", xlab="mu",main="Traceplot")
mean_vector_x[,1]
mean_vector_x
mean_vector_x=fit_x@.MISC$summary$msd
View(mean_vector_x)
View(mean_vector_x)
mean_vector_x=fit_x@.MISC$summary$msd[,1]
View(cred_vector_x)
View(eff_vector_x)
knitr::opts_chunk$set(echo = TRUE)
#install.packages("rstan")
mu=10
sigma_sq=2
T=200
x_init=mu
phi_vector=seq(-0.9,0.9,0.1)
results_matrix=matrix(0,200,length(phi_vector))
results_matrix[1,]=x_init
counter=1
set.seed(12345)
AR_process_function=function(mu, sigma_sq, T, phi) {
x_init=mu
result=rep(0,T)
result[1]=x_init
for (i in 2:T) {
epsilon=rnorm(1,0,sqrt(sigma_sq))
result[i]=mu+phi*(result[i-1]-mu)+epsilon
}
return(result)
}
results_matrix=matrix(0,T,length(phi_vector))
counter=1
for (phi in phi_vector) {
results_matrix[,counter]=AR_process_function(mu,sigma_sq,T,phi)
counter=counter+1
}
iter=seq(1,200,1)
counter=1
for (i in 1:length(phi_vector)) {
if (counter %% 6 == 0) {
plot(iter, results_matrix[,i], main="Plot of realization of AR-process", sub=paste("Phi =", phi_vector[i]),
xlab="Iteration", ylab="Value", type="l", col="grey")
}
counter=counter+1
}
library(rstan)
x=rep(0,T)
y=rep(0,T)
set.seed(12345)
x=AR_process_function(mu, sigma_sq, T, 0.3)
set.seed(12345)
y=AR_process_function(mu, sigma_sq, T, 0.95)
StanModel= '
data {
int<lower=0> N;
vector[N] y;
}
parameters {
real mu;
real phi;
real<lower=0> sigma;
}
model {
for (n in 2:N)
y[n] ~ normal(mu + phi * (y[n-1]-mu), sigma);
}
'
data_x=list(N=T, y=x)
data_y=list(N=T, y=y)
fit_x=stan(model_code=StanModel, data=data_x)
fit_y=stan(model_code=StanModel, data=data_y)
library(rstan)
postDraws_x <- extract(fit_x)
postDraws_y <- extract(fit_y)
print(fit_x)
print(fit_y)
mean_vector_x=fit_x@.MISC$summary$msd[,1]
cred_vector_x=fit_x@.MISC$summary$quan
eff_vector_x=fit_x@.MISC$summary$ess
mean_vector_y=fit_y@.MISC$summary$msd[,1]
cred_vector_y=fit_y@.MISC$summary$quan
eff_vector_y=fit_y@.MISC$summary$ess
# Do traceplots of the first chain
plot(postDraws_x$mu[1000:2000], postDraws_x$phi[1000:2000],ylab="phi", xlab="mu", main="Traceplot")
# Do traceplots of the first chain
plot(postDraws_y$mu[1000:2000],postDraws_y$phi[1000:2000],ylab="mu", xlab="mu",main="Traceplot")
View(cred_vector_y)
```{r results="hide"}
knitr::opts_chunk$set(echo = TRUE)
#install.packages("rstan")
mu=10
sigma_sq=2
T=200
x_init=mu
phi_vector=seq(-0.9,0.9,0.1)
results_matrix=matrix(0,200,length(phi_vector))
results_matrix[1,]=x_init
counter=1
set.seed(12345)
AR_process_function=function(mu, sigma_sq, T, phi) {
x_init=mu
result=rep(0,T)
result[1]=x_init
for (i in 2:T) {
epsilon=rnorm(1,0,sqrt(sigma_sq))
result[i]=mu+phi*(result[i-1]-mu)+epsilon
}
return(result)
}
results_matrix=matrix(0,T,length(phi_vector))
counter=1
for (phi in phi_vector) {
results_matrix[,counter]=AR_process_function(mu,sigma_sq,T,phi)
counter=counter+1
}
iter=seq(1,200,1)
counter=1
for (i in 1:length(phi_vector)) {
if (counter %% 6 == 0) {
plot(iter, results_matrix[,i], main="Plot of realization of AR-process", sub=paste("Phi =", phi_vector[i]),
xlab="Iteration", ylab="Value", type="l", col="grey")
}
counter=counter+1
}
library(rstan)
x=rep(0,T)
y=rep(0,T)
set.seed(12345)
x=AR_process_function(mu, sigma_sq, T, 0.3)
set.seed(12345)
y=AR_process_function(mu, sigma_sq, T, 0.95)
StanModel= '
data {
int<lower=0> N;
vector[N] y;
}
parameters {
real mu;
real phi;
real<lower=0> sigma;
}
model {
for (n in 2:N)
y[n] ~ normal(mu + phi * (y[n-1]-mu), sigma);
}
'
data_x=list(N=T, y=x)
data_y=list(N=T, y=y)
fit_x=stan(model_code=StanModel, data=data_x)
fit_y=stan(model_code=StanModel, data=data_y)
library(rstan)
postDraws_x <- extract(fit_x)
postDraws_y <- extract(fit_y)
print(fit_x)
print(fit_y)
mean_vector_x=fit_x@.MISC$summary$msd[,1]
cred_vector_x=fit_x@.MISC$summary$quan
eff_vector_x=fit_x@.MISC$summary$ess
mean_vector_y=fit_y@.MISC$summary$msd[,1]
cred_vector_y=fit_y@.MISC$summary$quan
eff_vector_y=fit_y@.MISC$summary$ess
# Do traceplots of the first chain
plot(postDraws_x$mu[1000:2000], postDraws_x$phi[1000:2000],ylab="phi", xlab="mu", main="Traceplot")
# Do traceplots of the first chain
plot(postDraws_y$mu[1000:2000],postDraws_y$phi[1000:2000],ylab="mu", xlab="mu",main="Traceplot")
campy=read.table("campy.dat", header=TRUE)
library(rstan)
StanModel_Pois = '
data {
int<lower=0> T;
int c[T];
}
parameters {
real mu;
real phi;
real<lower=0> sigma;
vector[T] x;
}
model {
// Prior
phi ~ uniform(-1,1);
for (n in 2:T)
x[n] ~ normal(mu + phi * (x[n-1]-mu), sigma);
// Model/likelihood
for (n in 1:T)
c[n] ~ poisson(exp(x[n]));
}
generated quantities {
vector[T] post_mean;
post_mean = exp(x);
}
'
data=list(T=dim(campy)[1], c=campy$c)
fit_pois=stan(model_code=StanModel_Pois, data=data)
print(fit_pois)
pois_mean_list=fit_pois@.MISC$summary$msd
post_mean=pois_mean_list[grep("post_mean", rownames(pois_mean_list)),]
plot(campy$c, col="blue", ylab="No. of infected", xlab="Time")
points(post_mean[,1], col="black", type="l")
quantiles=fit_pois@.MISC$summary$quan
quantiles_post_mean=quantiles[grep("post_mean", rownames(quantiles)),]
cred_interval_post_mean=matrix(0,dim(quantiles_post_mean)[1], 2)
cred_interval_post_mean[,1]=quantiles_post_mean[,1]
cred_interval_post_mean[,2]=quantiles_post_mean[,ncol(quantiles_post_mean)]
lines(cred_interval_post_mean[,1], col="gray", lty=21)
lines(cred_interval_post_mean[,2], col="gray", lty=21)
title(main="Plot of data vs approximated posterior")
legend("topleft", box.lty= 1, pch=c(1,NaN,NaN), legend=c("Data", "Posterior mean", "95 % cred. interval"),
col=c("blue", "black", "gray"), lwd=c(NaN,1,1), lty=c(NaN, 1, 21))
knitr::opts_chunk$set(echo = TRUE)
#install.packages("rstan")
mu=10
sigma_sq=2
T=200
x_init=mu
phi_vector=seq(-0.9,0.9,0.1)
results_matrix=matrix(0,200,length(phi_vector))
results_matrix[1,]=x_init
counter=1
set.seed(12345)
AR_process_function=function(mu, sigma_sq, T, phi) {
x_init=mu
result=rep(0,T)
result[1]=x_init
for (i in 2:T) {
epsilon=rnorm(1,0,sqrt(sigma_sq))
result[i]=mu+phi*(result[i-1]-mu)+epsilon
}
return(result)
}
results_matrix=matrix(0,T,length(phi_vector))
counter=1
for (phi in phi_vector) {
results_matrix[,counter]=AR_process_function(mu,sigma_sq,T,phi)
counter=counter+1
}
iter=seq(1,200,1)
counter=1
for (i in 1:length(phi_vector)) {
if (counter %% 6 == 0) {
plot(iter, results_matrix[,i], main="Plot of realization of AR-process", sub=paste("Phi =", phi_vector[i]),
xlab="Iteration", ylab="Value", type="l", col="grey")
}
counter=counter+1
}
library(rstan)
x=rep(0,T)
y=rep(0,T)
set.seed(12345)
x=AR_process_function(mu, sigma_sq, T, 0.3)
set.seed(12345)
y=AR_process_function(mu, sigma_sq, T, 0.95)
StanModel= '
data {
int<lower=0> N;
vector[N] y;
}
parameters {
real mu;
real phi;
real<lower=0> sigma;
}
model {
for (n in 2:N)
y[n] ~ normal(mu + phi * (y[n-1]-mu), sigma);
}
'
data_x=list(N=T, y=x)
data_y=list(N=T, y=y)
fit_x=stan(model_code=StanModel, data=data_x)
fit_y=stan(model_code=StanModel, data=data_y)
library(rstan)
postDraws_x <- extract(fit_x)
postDraws_y <- extract(fit_y)
print(fit_x)
print(fit_y)
mean_vector_x=fit_x@.MISC$summary$msd[,1]
cred_vector_x=fit_x@.MISC$summary$quan
eff_vector_x=fit_x@.MISC$summary$ess
mean_vector_y=fit_y@.MISC$summary$msd[,1]
cred_vector_y=fit_y@.MISC$summary$quan
eff_vector_y=fit_y@.MISC$summary$ess
# Do traceplots of the first chain
plot(postDraws_x$mu[1000:2000], postDraws_x$phi[1000:2000],ylab="phi", xlab="mu", main="Traceplot")
# Do traceplots of the first chain
plot(postDraws_y$mu[1000:2000],postDraws_y$phi[1000:2000],ylab="mu", xlab="mu",main="Traceplot")
campy=read.table("campy.dat", header=TRUE)
library(rstan)
StanModel_Pois = '
data {
int<lower=0> T;
int c[T];
}
parameters {
real mu;
real phi;
real<lower=0> sigma;
vector[T] x;
}
model {
// Prior
phi ~ uniform(-1,1);
for (n in 2:T)
x[n] ~ normal(mu + phi * (x[n-1]-mu), sigma);
// Model/likelihood
for (n in 1:T)
c[n] ~ poisson(exp(x[n]));
}
generated quantities {
vector[T] post_mean;
post_mean = exp(x);
}
'
data=list(T=dim(campy)[1], c=campy$c)
fit_pois=stan(model_code=StanModel_Pois, data=data)
print(fit_pois)
pois_mean_list=fit_pois@.MISC$summary$msd
post_mean=pois_mean_list[grep("post_mean", rownames(pois_mean_list)),]
plot(campy$c, col="blue", ylab="No. of infected", xlab="Time")
points(post_mean[,1], col="black", type="l")
quantiles=fit_pois@.MISC$summary$quan
quantiles_post_mean=quantiles[grep("post_mean", rownames(quantiles)),]
cred_interval_post_mean=matrix(0,dim(quantiles_post_mean)[1], 2)
cred_interval_post_mean[,1]=quantiles_post_mean[,1]
cred_interval_post_mean[,2]=quantiles_post_mean[,ncol(quantiles_post_mean)]
lines(cred_interval_post_mean[,1], col="gray", lty=21)
lines(cred_interval_post_mean[,2], col="gray", lty=21)
title(main="Plot of data vs approximated posterior")
legend("topleft", box.lty= 1, pch=c(1,NaN,NaN), legend=c("Data", "Posterior mean", "95 % cred. interval"),
col=c("blue", "black", "gray"), lwd=c(NaN,1,1), lty=c(NaN, 1, 21))
StanModel_Pois_Prior = '
data {
int<lower=0> T;
int c[T];
}
parameters {
real mu;
real phi;
real<lower=0> sigma;
vector[T] x;
}
model {
// Prior
phi ~ uniform(-1,1);
sigma ~ scaled_inv_chi_square(140, 0.15);
for (n in 2:T)
x[n] ~ normal(mu + phi * (x[n-1]-mu), sigma);
// Model/likelihood
for (n in 1:T)
c[n] ~ poisson(exp(x[n]));
}
generated quantities {
vector[T] post_mean;
post_mean = exp(x);
}
'
fit_pois_prior=stan(model_code=StanModel_Pois_Prior, data=data)
print(fit_pois_prior)
pois_mean_list_prior=fit_pois_prior@.MISC$summary$msd
post_mean_prior=pois_mean_list_prior[grep("post_mean", rownames(pois_mean_list)),]
plot(campy$c, col="blue", ylab="No. of infected", xlab="Time")
points(post_mean_prior[,1], col="black", type="l")
quantiles_prior=fit_pois_prior@.MISC$summary$quan
quantiles_post_mean_prior=quantiles_prior[grep("post_mean", rownames(quantiles)),]
cred_interval_post_mean_prior=matrix(0,dim(quantiles_post_mean)[1], 2)
cred_interval_post_mean_prior[,1]=quantiles_post_mean_prior[,1]
cred_interval_post_mean_prior[,2]=quantiles_post_mean_prior[,ncol(quantiles_post_mean)]
lines(cred_interval_post_mean_prior[,1], col="gray", lty=21)
lines(cred_interval_post_mean_prior[,2], col="gray", lty=21)
title(main="Plot of data vs approximated posterior")
legend("topleft", box.lty= 1, pch=c(1,NaN,NaN), legend=c("Data", "Posterior mean", "95 % cred. interval"),
col=c("blue", "black", "gray"), lwd=c(NaN,1,1), lty=c(NaN, 1, 21))
plot(campy$c, col="blue", ylab="No. of infected", xlab="Time")
points(post_mean[,1], col="black", type="l")
quantiles=fit_pois@.MISC$summary$quan
quantiles_post_mean=quantiles[grep("post_mean", rownames(quantiles)),]
cred_interval_post_mean=matrix(0,dim(quantiles_post_mean)[1], 2)
cred_interval_post_mean[,1]=quantiles_post_mean[,1]
cred_interval_post_mean[,2]=quantiles_post_mean[,ncol(quantiles_post_mean)]
lines(cred_interval_post_mean[,1], col="gray", lty=1)
lines(cred_interval_post_mean[,2], col="gray", lty=1)
title(main="Plot of data vs approximated posterior")
legend("topleft", box.lty= 1, pch=c(1,NaN,NaN), legend=c("Data", "Posterior mean", "95 % cred. interval"),
col=c("blue", "black", "gray"), lwd=c(NaN,1,1), lty=c(NaN, 1, 1))
